# Discord Chat Export Parser

This module provides comprehensive parsing and chunking functionality for Discord HTML exports generated by [DiscordChatExporter](https://github.com/Tyrrrz/DiscordChatExporter).

## Features

### Core Parsing Features
- **Accurate timestamp parsing** in Discord's format: "Friday, September 10, 2021 2:48:25 PM"
- **Multiple timestamp formats supported** with graceful fallback
- **Complete attachment extraction** including filename, URL, file type, and size
- **Reaction parsing** with emoji and count extraction  
- **System message handling** for Discord notifications
- **Reply message detection** with reference to original message ID
- **Message type classification** (Regular, System, Reply)

### Intelligent Chunking
- **Conversation-aware chunking** that preserves message context
- **Time-gap detection** for natural conversation breaks (15-minute threshold)
- **Topic shift detection** using content analysis heuristics  
- **Token estimation** for optimal chunk sizing
- **Continuation context generation** for seamless chunk transitions
- **Topic detection** with keyword-based classification

### Data Structures

#### `DiscordMessage`
```rust
pub struct DiscordMessage {
    pub id: String,
    pub author: String,
    pub timestamp: DateTime<Utc>,          // Parsed timestamp
    pub timestamp_raw: String,             // Original timestamp string
    pub content: String,
    pub attachments: Vec<Attachment>,
    pub reactions: Vec<Reaction>,
    pub reply_to: Option<String>,
    pub message_type: MessageType,
}
```

#### `Attachment`
```rust
pub struct Attachment {
    pub filename: String,
    pub url: String,
    pub file_type: Option<String>,  // Extracted from filename
    pub size: Option<String>,       // As reported by Discord
}
```

#### `Reaction`
```rust
pub struct Reaction {
    pub emoji: String,
    pub count: usize,
    pub users: Vec<String>,  // Currently empty - requires additional parsing
}
```

#### `MessageType`
```rust
pub enum MessageType {
    Regular,   // Normal user messages
    System,    // Discord system notifications
    Reply,     // Reply to another message
}
```

### Chunking Algorithm

The chunking algorithm uses multiple factors to determine conversation boundaries:

1. **Size limits** - Respects maximum token count per chunk
2. **Time gaps** - Breaks on gaps longer than 15 minutes
3. **Topic shifts** - Detects content changes using:
   - System message boundaries
   - Message length transitions
   - Question detection (what, how, why, when, where)
   - Attachment presence changes

### Topic Detection

Basic keyword-based topic classification includes:
- **Programming** - "code", "programming", "bug"
- **Scheduling** - "meeting", "schedule"  
- **Gaming** - "game", "play"
- **Music** - "music", "song"
- **Work** - "work", "project"
- **Images/Media** - Based on image attachments

### Error Handling

- **Graceful timestamp parsing** with multiple format fallbacks
- **Default values** for missing or malformed data
- **Structured error types** with detailed context
- **Non-blocking failures** - parsing continues even if individual messages fail

## Usage Examples

### Basic HTML Parsing
```rust
use vespera_file_ops::chunking::discord::parse_discord_html;

let chat_log = parse_discord_html("path/to/export.html")?;
println!("Parsed {} messages from {} participants", 
         chat_log.total_messages, 
         chat_log.participants.len());
```

### Conversation Chunking
```rust
use vespera_file_ops::chunking::discord::chunk_discord_export;

let chunks = chunk_discord_export(html_content, true, 1000)?;
for chunk in chunks {
    println!("Chunk: {} messages, {} participants, topics: {:?}",
             chunk.messages.len(),
             chunk.participants.len(),
             chunk.detected_topics);
}
```

### Working with Messages
```rust
for message in chat_log.messages {
    match message.message_type {
        MessageType::Regular => {
            println!("{}: {}", message.author, message.content);
            if !message.attachments.is_empty() {
                println!("  Attachments: {:?}", 
                        message.attachments.iter().map(|a| &a.filename).collect::<Vec<_>>());
            }
        }
        MessageType::System => {
            println!("System: {}", message.content);
        }
        MessageType::Reply => {
            println!("{} (replying to {}): {}", 
                    message.author, 
                    message.reply_to.as_deref().unwrap_or("unknown"), 
                    message.content);
        }
    }
}
```

## HTML Format Support

The parser is designed for HTML exports from DiscordChatExporter and supports these CSS selectors:

- `.chatlog__message-container` - Main message containers
- `.chatlog__author` - Message author names
- `.chatlog__timestamp[title]` - Timestamp data in title attribute
- `.chatlog__content` - Message text content
- `.chatlog__attachment` - File attachments
- `.chatlog__attachment-name` - Attachment filenames  
- `.chatlog__attachment-size` - File size information
- `.chatlog__reactions` - Reaction containers
- `.chatlog__reaction` - Individual reactions
- `.chatlog__system-notification-content` - System messages
- `.chatlog__reply-link[onclick]` - Reply references

## Testing

Comprehensive test suite covers:
- Timestamp parsing with multiple formats
- HTML parsing with sample Discord export
- Message type detection
- Attachment and reaction extraction  
- Conversation chunking logic
- Token estimation accuracy
- Topic detection algorithms

Run tests with:
```bash
cargo test discord --lib
```

## Performance Considerations

- **Memory efficient** - Streaming HTML parsing with scraper crate
- **Token estimation** - Fast character-based approximation (1 token â‰ˆ 4 characters)
- **Selective parsing** - Only extracts required data fields
- **Graceful degradation** - Continues parsing even with malformed HTML sections

## Integration

This parser integrates with the broader Vespera chunking system and can be used via:
- Direct function calls for programmatic use
- MCP server integration for tool-based access
- Python bindings for cross-language compatibility

The parsed data structures are fully serializable with serde for easy storage and transmission.