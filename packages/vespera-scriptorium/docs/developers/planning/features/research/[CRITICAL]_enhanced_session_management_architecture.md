

# 🏗️ Enhanced Session Management Architecture

**Document Type**: Architecture Design Specification  
**Version**: 1.0.0  
**Created**: 2025-06-01  
**Status**: [CRITICAL] - Required for fixing usability-blocking issues  
**Priority**: CRITICAL - Blocking Issue #36 (Working Directory Detection)  
**Updated**: 2025-06-08 - Moved to CRITICAL due to production issues  
**Scope**: Complete session management architecture with database, persistence, and tool integration

---

#

# ⚠️ CRITICAL IMPLEMENTATION NOTICE

**This feature has been elevated to CRITICAL status due to production-blocking issues:**

- **Issue #36**: Orchestrator files created in wrong directory

- **User Impact**: Users cannot control where .task_orchestrator folder is created

- **Required Fix**: Session-directory association with persistent session management

The `working_directory` parameter has been added to `orchestrator_initialize_session` as an immediate fix, but full session management with directory persistence is required for a complete solution.

#

# 🎯 Executive Summary

#

#

# Architectural Vision

Transform the MCP Task Orchestrator from a task-focused system into a **session-aware organizational framework** where:

- **Sessions** represent large, cohesive project units (comparable to GitHub repositories or project workspaces)

- **Tasks** become components within sessions, organized hierarchically

- **One active session** provides focused context and eliminates cognitive overhead

- **Bi-directional persistence** ensures human-readable project organization

- **Mode-based specialization** adapts orchestrator behavior to project types

#

#

# Core Architectural Principles

1. **Session-First Design**: All orchestration operations occur within session context

2. **Single Active Session**: Only one session active at a time for focused execution

3. **Hierarchical Organization**: Sessions → Task Groups → Tasks → Subtasks

4. **Dual Persistence**: Database performance + Human-readable markdown files

5. **Mode-Driven Behavior**: Session-linked specialist role configurations

6. **Graceful Migration**: Backward compatibility with existing task-only workflows

---

#

# 🏛️ System Architecture Overview

#

#

# Current Architecture Transformation

```text
BEFORE (Task-Focused):
Claude Desktop → MCP Tools → Task Orchestrator → Tasks → Database

AFTER (Session-Aware):
Claude Desktop → MCP Tools → Session Manager → Active Session → Task Groups → Tasks → Dual Persistence
                                    ↓
                            Mode System + Role Configuration

```text

#

#

# Core Components Architecture

```text

Session Management Layer
├── Session Manager (Core orchestration)
├── Active Session Context (Single active session state)
├── Session State Machine (Lifecycle management)
└── Session Registry (Multiple session storage)

Task Organization Layer  
├── Task Group Manager (Hierarchical organization)
├── Task Dependency Engine (Enhanced dependencies)
├── Task Lifecycle Coordinator (State management)
└── Progress Aggregation Engine (Recursive progress)

Persistence Layer
├── Database Persistence (SQLite with enhanced schema)
├── Markdown File Generator (Human-readable files)
├── Bi-directional Sync Engine (DB ↔ .md sync)
└── File System Monitor (Change detection)

Mode & Configuration Layer
├── Mode Manager (Role configuration system)
├── Role Configuration Engine (Dynamic role loading)
├── Session-Mode Binding (Session-specific behavior)
└── Recovery System (Missing file handling)

Integration Layer
├── MCP Tool Router (Enhanced tool suite)
├── Backward Compatibility Adapter (Legacy support)
├── A2A Framework Integration (Agent coordination)
└── External Tool Coordination (Multi-server support)

```text

---

#

# 📊 Enhanced Database Schema Design

#

#

# Session Management Schema

```text
sql
-- =====================================================
-- SESSIONS TABLE: Core session management
-- =====================================================
CREATE TABLE sessions (
    session_id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    session_type TEXT DEFAULT 'project',  -- project, maintenance, research, etc.
    mode_file TEXT,  -- Reference to .yaml role configuration
    status TEXT DEFAULT 'active',  -- active, paused, completed, archived
    
    -- Organizational metadata
    project_root_path TEXT,  -- Base directory for .task_orchestrator files
    markdown_file_path TEXT,  -- Path to human-readable session.md
    priority_level INTEGER DEFAULT 3,  -- 1=urgent, 2=high, 3=medium, 4=low, 5=someday
    
    -- Tracking and metrics
    total_tasks INTEGER DEFAULT 0,
    completed_tasks INTEGER DEFAULT 0,
    progress_percentage REAL DEFAULT 0.0,
    estimated_completion_date TIMESTAMP,
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    activated_at TIMESTAMP,
    last_activity_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    archived_at TIMESTAMP,
    
    -- Constraints
    CHECK (priority_level BETWEEN 1 AND 5),
    CHECK (progress_percentage BETWEEN 0.0 AND 100.0)
);

-- =====================================================
-- ACTIVE SESSION MANAGEMENT: Only one active session
-- =====================================================
CREATE TABLE active_session (
    id INTEGER PRIMARY KEY CHECK (id = 1),  -- Singleton table
    session_id TEXT NOT NULL,
    activated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    context_data JSON,  -- Cached session context for performance
    
    FOREIGN KEY (session_id) REFERENCES sessions (session_id) ON DELETE CASCADE
);

-- =====================================================
-- ENHANCED TASKS TABLE: Session-aware task management
-- =====================================================
CREATE TABLE tasks (
    task_id TEXT PRIMARY KEY,
    session_id TEXT NOT NULL,  -- All tasks belong to a session
    parent_task_id TEXT,
    root_task_id TEXT,
    
    -- Task organization
    task_group TEXT,  -- Logical grouping within session (e.g., 'frontend', 'backend')
    level INTEGER DEFAULT 0,
    hierarchy_path TEXT,  -- Materialized path: /session/group/task
    position_in_group INTEGER DEFAULT 0,  -- Ordering within group
    
    -- Task details
    title TEXT NOT NULL,
    description TEXT,
    specialist_type TEXT,
    complexity_level TEXT DEFAULT 'moderate',
    
    -- Status and progress
    status TEXT DEFAULT 'pending',
    progress_percentage REAL DEFAULT 0.0,
    estimated_effort INTEGER,  -- In hours
    actual_effort INTEGER,     -- In hours
    
    -- Dependencies and relationships
    depends_on JSON,  -- List of prerequisite task IDs
    blocks JSON,      -- List of dependent task IDs
    related_tasks JSON,  -- List of related task IDs
    
    -- Persistence tracking
    markdown_section TEXT,  -- Section in session markdown file
    file_operations_count INTEGER DEFAULT 0,
    verification_status TEXT DEFAULT 'pending',
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    last_updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Foreign keys and constraints
    FOREIGN KEY (session_id) REFERENCES sessions (session_id) ON DELETE CASCADE,
    FOREIGN KEY (parent_task_id) REFERENCES tasks (task_id) ON DELETE CASCADE,
    FOREIGN KEY (root_task_id) REFERENCES tasks (task_id) ON DELETE CASCADE,
    
    CHECK (level >= 0),
    CHECK (progress_percentage BETWEEN 0.0 AND 100.0),
    CHECK (estimated_effort >= 0),
    CHECK (actual_effort >= 0)
);

-- =====================================================
-- SESSION MODES: Role configuration system
-- =====================================================
CREATE TABLE session_modes (
    mode_id TEXT PRIMARY KEY,
    mode_name TEXT NOT NULL,
    yaml_file_path TEXT NOT NULL,
    yaml_content_hash TEXT,  -- For change detection
    
    -- Mode metadata
    description TEXT,
    specialist_roles JSON,  -- Available roles in this mode
    default_complexity TEXT DEFAULT 'moderate',
    auto_task_routing BOOLEAN DEFAULT FALSE,
    
    -- Validation
    is_valid BOOLEAN DEFAULT TRUE,
    last_validated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    validation_errors JSON,
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE (yaml_file_path)
);

-- =====================================================
-- SESSION-MODE BINDING: Link sessions to modes
-- =====================================================
CREATE TABLE session_mode_bindings (
    session_id TEXT NOT NULL,
    mode_id TEXT NOT NULL,
    bound_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    binding_context JSON,  -- Additional configuration for this binding
    
    PRIMARY KEY (session_id, mode_id),
    FOREIGN KEY (session_id) REFERENCES sessions (session_id) ON DELETE CASCADE,
    FOREIGN KEY (mode_id) REFERENCES session_modes (mode_id) ON DELETE CASCADE
);

-- =====================================================
-- TASK GROUPS: Logical organization within sessions
-- =====================================================
CREATE TABLE task_groups (
    group_id TEXT PRIMARY KEY,
    session_id TEXT NOT NULL,
    group_name TEXT NOT NULL,
    description TEXT,
    
    -- Group organization
    parent_group_id TEXT,  -- Support nested groups
    group_level INTEGER DEFAULT 0,
    position_in_session INTEGER DEFAULT 0,
    
    -- Group metadata
    specialist_focus TEXT,  -- Primary specialist type for this group
    estimated_effort INTEGER DEFAULT 0,
    priority_level INTEGER DEFAULT 3,
    
    -- Progress tracking
    total_tasks INTEGER DEFAULT 0,
    completed_tasks INTEGER DEFAULT 0,
    progress_percentage REAL DEFAULT 0.0,
    
    -- Persistence
    markdown_section TEXT,  -- Section in session markdown
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Foreign keys and constraints
    FOREIGN KEY (session_id) REFERENCES sessions (session_id) ON DELETE CASCADE,
    FOREIGN KEY (parent_group_id) REFERENCES task_groups (group_id) ON DELETE CASCADE,
    
    CHECK (group_level >= 0),
    CHECK (priority_level BETWEEN 1 AND 5),
    CHECK (progress_percentage BETWEEN 0.0 AND 100.0),
    UNIQUE (session_id, group_name)
);

-- =====================================================
-- MARKDOWN SYNC: Bi-directional persistence tracking
-- =====================================================
CREATE TABLE markdown_sync_state (
    sync_id TEXT PRIMARY KEY,
    session_id TEXT NOT NULL,
    markdown_file_path TEXT NOT NULL,
    
    -- Sync status
    last_db_to_md_sync TIMESTAMP,
    last_md_to_db_sync TIMESTAMP,
    sync_status TEXT DEFAULT 'synchronized',  -- synchronized, db_newer, md_newer, conflict
    
    -- Content tracking
    db_content_hash TEXT,
    md_content_hash TEXT,
    last_conflict_resolution TIMESTAMP,
    
    -- Change detection
    file_monitor_active BOOLEAN DEFAULT TRUE,
    last_file_modification TIMESTAMP,
    
    FOREIGN KEY (session_id) REFERENCES sessions (session_id) ON DELETE CASCADE,
    UNIQUE (session_id, markdown_file_path)
);

```text

#

#

# Database Indexes for Performance

```text
sql
-- Performance optimization indexes
CREATE INDEX idx_sessions_status ON sessions (status);
CREATE INDEX idx_sessions_priority ON sessions (priority_level);
CREATE INDEX idx_sessions_activity ON sessions (last_activity_at);

CREATE INDEX idx_tasks_session ON tasks (session_id);
CREATE INDEX idx_tasks_hierarchy ON tasks (session_id, hierarchy_path);
CREATE INDEX idx_tasks_status ON tasks (session_id, status);
CREATE INDEX idx_tasks_group ON tasks (session_id, task_group);
CREATE INDEX idx_tasks_parent ON tasks (parent_task_id);

CREATE INDEX idx_task_groups_session ON task_groups (session_id);
CREATE INDEX idx_task_groups_parent ON task_groups (parent_group_id);

CREATE INDEX idx_markdown_sync_session ON markdown_sync_state (session_id);
CREATE INDEX idx_markdown_sync_status ON markdown_sync_state (sync_status);

```text

---

#

# 🔄 Session State Machine

#

#

# Session Lifecycle States

```text
python
class SessionState(Enum):
    CREATING = "creating"      

# Session being initialized

    ACTIVE = "active"         

# Currently active session (only one allowed)

    PAUSED = "paused"         

# Temporarily inactive but resumable

    COMPLETED = "completed"   

# All tasks finished successfully

    ARCHIVED = "archived"     

# Moved to long-term storage

    CANCELLED = "cancelled"   

# Terminated before completion

    ERROR = "error"          

# Failed state requiring intervention

class SessionStateTransitions:
    ALLOWED_TRANSITIONS = {
        SessionState.CREATING: [SessionState.ACTIVE, SessionState.CANCELLED],
        SessionState.ACTIVE: [SessionState.PAUSED, SessionState.COMPLETED, SessionState.CANCELLED],
        SessionState.PAUSED: [SessionState.ACTIVE, SessionState.ARCHIVED, SessionState.CANCELLED],
        SessionState.COMPLETED: [SessionState.ARCHIVED],
        SessionState.ARCHIVED: [SessionState.ACTIVE],  

# Can reactivate archived sessions

        SessionState.CANCELLED: [SessionState.ARCHIVED],
        SessionState.ERROR: [SessionState.ACTIVE, SessionState.CANCELLED]  

# Recovery paths

    }

```text

#

#

# Session Lifecycle Architecture

```text
python
class SessionManager:
    def __init__(self, db_manager, file_system_manager, mode_manager):
        self.db = db_manager
        self.fs = file_system_manager
        self.mode_manager = mode_manager
        self.active_session_cache = None
    
    async def create_session(self, name: str, description: str, 
                           project_root: str, mode_file: str = None) -> Session:
        """Create new session with automatic directory setup."""
        
        

# Validate only one active session

        if await self.get_active_session():
            raise ActiveSessionExistsError("Cannot create session while another is active")
        
        

# Create session entity

        session = Session(
            session_id=generate_session_id(),
            name=name,
            description=description,
            project_root_path=project_root,
            mode_file=mode_file or "default_roles.yaml",
            status=SessionState.CREATING
        )
        
        

# Setup file system structure

        await self.setup_session_directory(session)
        
        

# Initialize markdown file

        await self.create_session_markdown(session)
        
        

# Bind to mode

        if mode_file:
            await self.mode_manager.bind_session_to_mode(session.session_id, mode_file)
        
        

# Save to database

        await self.db.save_session(session)
        
        

# Activate immediately

        await self.activate_session(session.session_id)
        
        return session
    
    async def activate_session(self, session_id: str) -> Session:
        """Activate session as the single active session."""
        
        

# Deactivate current active session

        current_active = await self.get_active_session()
        if current_active and current_active.session_id != session_id:
            await self.pause_session(current_active.session_id)
        
        

# Activate new session

        session = await self.db.get_session(session_id)
        if not session:
            raise SessionNotFoundError(f"Session {session_id} not found")
        
        

# Validate session can be activated

        if session.status not in [SessionState.CREATING, SessionState.PAUSED, SessionState.ARCHIVED]:
            raise InvalidSessionStateError(f"Cannot activate session in state {session.status}")
        
        

# Update session state

        session.status = SessionState.ACTIVE
        session.activated_at = datetime.utcnow()
        session.last_activity_at = datetime.utcnow()
        
        

# Set as active session

        await self.db.set_active_session(session_id, self.build_session_context(session))
        
        

# Update cache

        self.active_session_cache = session
        
        

# Initialize session context

        await self.initialize_session_context(session)
        
        return session
    
    async def setup_session_directory(self, session: Session):
        """Create .task_orchestrator directory structure for session."""
        
        session_dir = Path(session.project_root_path) / ".task_orchestrator"
        
        

# Create directory structure

        directories = [
            session_dir,
            session_dir / "sessions",
            session_dir / "roles",
            session_dir / "tasks",
            session_dir / "archives",
            session_dir / "exports"
        ]
        
        for directory in directories:
            directory.mkdir(parents=True, exist_ok=True)
        
        

# Copy default roles if roles directory is empty

        roles_dir = session_dir / "roles"
        if not any(roles_dir.glob("*.yaml")):
            await self.copy_default_roles(roles_dir)
        
        

# Create session-specific subdirectories

        session_subdir = session_dir / "sessions" / session.session_id
        session_subdir.mkdir(exist_ok=True)
        
        

# Update session with directory paths

        session.markdown_file_path = str(session_subdir / "session.md")
        
    async def copy_default_roles(self, target_dir: Path):
        """Copy default role configurations to session directory."""
        
        

# Source: project config directory

        config_dir = Path(__file__).parent.parent.parent / "config"
        default_roles_file = config_dir / "default_roles.yaml"
        
        if default_roles_file.exists():
            target_file = target_dir / "default_roles.yaml"
            shutil.copy2(default_roles_file, target_file)
        
        

# Also copy any other .yaml files from config

        for yaml_file in config_dir.glob("*.yaml"):
            if yaml_file.name != "default_roles.yaml":
                target_file = target_dir / yaml_file.name
                shutil.copy2(yaml_file, target_file)

```text

---

#

# 📄 Bi-directional Markdown Persistence

#

#

# Session Markdown Structure

```text
markdown

# 📋 Session: [Session Name]

**Session ID**: `[session_id]`  
**Status**: [Active|Paused|Completed]  
**Mode**: [mode_name] ([yaml_file])  
**Created**: [timestamp]  
**Progress**: [percentage]% ([completed_tasks]/[total_tasks] tasks)

#

# 📊 Session Overview

[Auto-generated session description and context]

#

#

# Key Metrics

- **Total Tasks**: [count]

- **Completed**: [count] ([percentage]%)

- **In Progress**: [count]

- **Estimated Completion**: [date]

#

# 🎯 Task Groups

#

#

# [Group Name 1]

**Progress**: [percentage]% ([completed]/[total] tasks)  
**Focus**: [specialist_focus]  
**Priority**: [level]

#

#

#

# Tasks in [Group Name 1]

- [ ] [Task 1] (Pending) - [specialist_type] - [estimated_effort]h

- [x] [Task 2] (Completed) - [specialist_type] - [actual_effort]h

- [ ] [Task 3] (In Progress) - [specialist_type] - [estimated_effort]h

#

#

# [Group Name 2]

[Similar structure...]

#

# 📝 Session Notes

#

#

# Decisions Made

[Auto-generated from decision documentation system]

#

#

# Key Learnings

[Space for user notes - monitored for changes]

#

#

# Next Steps

[Auto-generated and user-editable]

#

# 🔄 Change Log

[Auto-generated log of significant session changes]

---
**Last Updated**: [timestamp] (Auto-sync: [sync_status])  
**Total Session Time**: [calculated_time]  
**Markdown File**: [file_path]

```text

#

#

# Bi-directional Sync Engine

```text
python
class MarkdownSyncEngine:
    def __init__(self, db_manager, file_monitor):
        self.db = db_manager
        self.file_monitor = file_monitor
        self.sync_queue = asyncio.Queue()
        self.sync_lock = asyncio.Lock()
    
    async def sync_db_to_markdown(self, session_id: str):
        """Generate markdown file from database state."""
        
        async with self.sync_lock:
            session = await self.db.get_session(session_id)
            task_groups = await self.db.get_session_task_groups(session_id)
            tasks = await self.db.get_session_tasks(session_id)
            
            

# Generate markdown content

            markdown_content = self.generate_session_markdown(session, task_groups, tasks)
            
            

# Write to file

            markdown_path = Path(session.markdown_file_path)
            async with aiofiles.open(markdown_path, 'w', encoding='utf-8') as f:
                await f.write(markdown_content)
            
            

# Update sync state

            await self.update_sync_state(session_id, 'db_to_md')
    
    async def sync_markdown_to_db(self, session_id: str):
        """Parse markdown file and update database state."""
        
        async with self.sync_lock:
            session = await self.db.get_session(session_id)
            markdown_path = Path(session.markdown_file_path)
            
            if not markdown_path.exists():
                return
            
            

# Read and parse markdown

            async with aiofiles.open(markdown_path, 'r', encoding='utf-8') as f:
                content = await f.read()
            
            changes = self.parse_user_changes(content, session_id)
            
            

# Apply changes to database

            for change in changes:
                await self.apply_change_to_db(change)
            
            

# Update sync state

            await self.update_sync_state(session_id, 'md_to_db')
    
    def parse_user_changes(self, markdown_content: str, session_id: str) -> List[Change]:
        """Parse markdown content for user changes."""
        
        changes = []
        
        

# Parse task status changes (checkbox state changes)

        task_pattern = r'- \[([ x])\] (.+?) \((.+?)\)'
        for match in re.finditer(task_pattern, markdown_content):
            is_completed = match.group(1) == 'x'
            task_name = match.group(2)
            status = match.group(3)
            
            

# Find task in database and check for status changes

            

# ... implementation details

        
        

# Parse session notes changes

        notes_section = self.extract_section(markdown_content, "

#

# 📝 Session Notes")

        if notes_section:
            

# Detect changes in user-editable sections

            

# ... implementation details

        
        return changes
    
    async def detect_conflicts(self, session_id: str) -> List[Conflict]:
        """Detect conflicts between database and markdown states."""
        
        

# Implementation for conflict detection

        

# Compare timestamps, content hashes, etc.

        pass
    
    async def resolve_conflict(self, conflict: Conflict, resolution: str):
        """Resolve sync conflict using specified strategy."""
        
        if resolution == 'db_wins':
            await self.sync_db_to_markdown(conflict.session_id)
        elif resolution == 'md_wins':
            await self.sync_markdown_to_db(conflict.session_id)
        elif resolution == 'merge':
            await self.merge_changes(conflict)

```text

---

#

# 🛠️ Enhanced MCP Tool Architecture

#

#

# Session Management Tools

```text
python

# New MCP tools for session management

ENHANCED_MCP_TOOLS = {
    

# Session Lifecycle Management

    "orchestrator_session_create": {
        "description": "Create new session with automatic setup",
        "parameters": {
            "name": "Session name",
            "description": "Session description", 
            "project_root": "Base directory path",
            "mode_file": "Role configuration file (optional)"
        }
    },
    
    "orchestrator_session_activate": {
        "description": "Activate session as the single active session",
        "parameters": {
            "session_id": "Session identifier"
        }
    },
    
    "orchestrator_session_list": {
        "description": "List all sessions with status and metadata",
        "parameters": {
            "status_filter": "Filter by status (optional)",
            "include_archived": "Include archived sessions (default: false)"
        }
    },
    
    "orchestrator_session_archive": {
        "description": "Archive session for long-term storage",
        "parameters": {
            "session_id": "Session identifier",
            "export_format": "Export format (markdown|json|zip)"
        }
    },
    
    

# Task Group Management

    "orchestrator_group_create": {
        "description": "Create task group within active session",
        "parameters": {
            "group_name": "Group name",
            "description": "Group description",
            "specialist_focus": "Primary specialist type",
            "parent_group": "Parent group (optional for nesting)"
        }
    },
    
    "orchestrator_group_move_tasks": {
        "description": "Move tasks between groups",
        "parameters": {
            "task_ids": "List of task identifiers",
            "target_group": "Target group name",
            "preserve_dependencies": "Maintain task dependencies (default: true)"
        }
    },
    
    

# Mode Management

    "orchestrator_mode_select": {
        "description": "Select and bind mode to active session",
        "parameters": {
            "mode_file": "Path to .yaml role configuration",
            "validate_first": "Validate mode before binding (default: true)"
        }
    },
    
    "orchestrator_mode_list": {
        "description": "List available modes in session directory",
        "parameters": {
            "include_invalid": "Include invalid modes (default: false)"
        }
    },
    
    

# Search and Discovery

    "orchestrator_search": {
        "description": "Search across sessions, tasks, and content",
        "parameters": {
            "query": "Search query",
            "scope": "Search scope (active|all_sessions|archived)",
            "content_types": "Content types (tasks|notes|decisions|all)"
        }
    },
    
    

# Cleanup and Maintenance

    "orchestrator_cleanup": {
        "description": "Clean up orphaned tasks, sync states, etc.",
        "parameters": {
            "scope": "Cleanup scope (active_session|all_sessions)",
            "dry_run": "Preview changes without applying (default: true)"
        }
    }
}

```text

---

#

# 🔗 Integration Architecture

#

#

# A2A Framework Integration

```text
python
class SessionAwareA2ACoordinator:
    """Integration with Agent-to-Agent framework for session management."""
    
    async def coordinate_session_across_agents(self, session_id: str):
        """Coordinate session state across multiple agents."""
        
        active_session = await self.session_manager.get_active_session()
        if not active_session or active_session.session_id != session_id:
            raise SessionNotActiveError("Session must be active for A2A coordination")
        
        

# Build session context for agents

        session_context = {
            "session_id": session_id,
            "session_name": active_session.name,
            "mode_configuration": await self.mode_manager.get_session_mode(session_id),
            "task_groups": await self.db.get_session_task_groups(session_id),
            "active_tasks": await self.db.get_active_tasks(session_id),
            "markdown_path": active_session.markdown_file_path
        }
        
        

# Distribute context to coordinating agents

        await self.a2a_client.broadcast_session_context(session_context)

#

#

# Backward Compatibility Layer

```python
class LegacyTaskCompatibilityAdapter:
    """Adapter to support legacy task-only operations."""
    
    async def handle_legacy_task_operation(self, operation: str, **kwargs):
        """Handle operations that assume task-only context."""
        
        

# Check if we have an active session

        active_session = await self.session_manager.get_active_session()
        
        if not active_session:
            

# Create temporary session for legacy operations

            temp_session = await self.session_manager.create_temp_session(
                name="Legacy Task Session",
                description="Temporary session for backward compatibility"
            )
            active_session = temp_session
        
        

# Route operation to session-aware implementation

        return await self.route_to_session_aware_operation(active_session, operation, **kwargs)
```text

---

#

# 📈 Performance Considerations

#

#

# Database Optimization Strategies

1. **Session Caching**: Cache active session context in memory

2. **Lazy Loading**: Load task groups and tasks on demand

3. **Materialized Paths**: Efficient hierarchy queries using path strings

4. **Connection Pooling**: Maintain pool of database connections

5. **Bulk Operations**: Batch task operations for better performance

#

#

# File System Optimization

1. **Debounced Sync**: Batch markdown updates to reduce I/O

2. **Change Detection**: Monitor only active session files

3. **Compression**: Compress archived session data

4. **Caching**: Cache parsed markdown content

#

#

# Memory Management

1. **Session Context Lifecycle**: Clear inactive session contexts

2. **Task Tree Pruning**: Limit in-memory task tree depth

3. **Garbage Collection**: Regular cleanup of orphaned objects

---

#

# 🚨 Security and Error Handling

#

#

# Security Considerations

1. **Path Validation**: Prevent directory traversal attacks

2. **File Permissions**: Secure .task_orchestrator directory access

3. **Session Isolation**: Prevent cross-session data access

4. **Input Validation**: Validate all user inputs from markdown files

#

#

# Error Recovery Strategies

1. **Session Corruption Recovery**: Rebuild session from markdown backup

2. **Database Recovery**: Restore from last known good state

3. **Sync Conflict Resolution**: Multiple resolution strategies

4. **Mode File Recovery**: Fallback to default mode if custom mode fails

---

#

# 🎯 Migration Strategy

#

#

# Phase 1: Database Schema Migration

- Add new tables while preserving existing ones

- Migrate existing tasks to default session

- Establish backward compatibility layer

#

#

# Phase 2: Session Management Introduction

- Enable session creation and management

- Maintain single active session concept

- Add markdown file generation

#

#

# Phase 3: Enhanced Features

- Full bi-directional sync implementation

- Advanced task group management

- Mode system integration

#

#

# Phase 4: Legacy Deprecation

- Gradual removal of task-only operations

- Full session-aware operation

- Performance optimization

---

**Architectural Status**: DESIGN COMPLETE ✅  
**Next Phase**: Implementation specifications and MCP tool design  
**Key Decisions**: Session-first architecture, single active session, dual persistence  
**Performance**: Optimized for 1000+ tasks per session, <100ms tool response times
